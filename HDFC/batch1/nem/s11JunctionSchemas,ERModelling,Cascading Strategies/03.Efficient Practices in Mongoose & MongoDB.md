
## üîπ Efficient Practices in Mongoose & MongoDB

### 1. **Use Indexing**

* Indexes speed up queries but cost extra write performance + memory.
* Common types:

  * **Single-field index** ‚Üí `{ email: 1 }`
  * **Compound index** ‚Üí `{ userId: 1, createdAt: -1 }`
  * **Text index** ‚Üí `{ title: "text", description: "text" }`
  * **Unique index** ‚Üí prevent duplicates (`{ email: 1, unique: true }`)

```js
const userSchema = new mongoose.Schema({
  email: { type: String, unique: true, index: true },
  name: String,
  createdAt: { type: Date, default: Date.now }
});
```

üëâ Rule:

* Index **fields used in queries** (`find`, `sort`, `populate`).
* Don‚Äôt over-index; each index increases write cost.

---

### 2. **Lean Queries**

* Use `.lean()` when you don‚Äôt need Mongoose document methods.
* Returns plain JS objects ‚Üí faster.

```js
const users = await User.find({ isActive: true }).lean();
```

---

### 3. **Projection**

* Fetch **only required fields** instead of entire document.

```js
// Only get name and email
const user = await User.findById(id, "name email");
```

---

### 4. **Populate Smartly**

* `populate` can be **expensive** (joins in MongoDB).
* Use **nested population carefully**.
* Fetch only required fields in populate.

```js
const blog = await Blog.findById(blogId)
  .populate("author", "name email")
  .populate("comments", "text createdAt");
```

---

### 5. **Schema Design Choices**

* **Embed small, bounded data** (e.g., addresses inside User).
* **Reference large / shared data** (e.g., Orders linked to User).
* Avoid **deep nesting** (MongoDB doc limit = 16MB).

---

### 6. **Use `select: false` for Sensitive Fields**

* Prevent accidental exposure of passwords, tokens.

```js
const userSchema = new mongoose.Schema({
  email: String,
  password: { type: String, select: false }
});
```

---

### 7. **Timestamps & Auditing**

* Always track changes.

```js
const blogSchema = new mongoose.Schema({
  title: String,
  content: String
}, { timestamps: true });
```

---

### 8. **Compound Queries & Partial Indexes**

* For queries like ‚Äúactive users by role‚Äù:

```js
userSchema.index({ role: 1, isActive: 1 });
```

* For partial conditions:

```js
userSchema.index({ email: 1 }, { unique: true, partialFilterExpression: { email: { $exists: true } } });
```

---

### 9. **Use Pagination (Not `.skip()` on large data)**

* Use **range queries / cursors** instead of skip/limit for huge collections.

```js
const blogs = await Blog.find({ _id: { $gt: lastId } }).limit(10);
```

---

### 10. **Validation & Consistency**

* Use **Mongoose schema validation** (min, max, enum, match).
* Add **custom validators** for domain logic.
* Use **MongoDB transactions** when multiple collections must update together.

---


